Index: app/src/main/java/com/example/pbk_test/PKRBLS.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.pbk_test;\n\nimport android.content.Context;\nimport android.os.Build;\n\nimport androidx.annotation.RequiresApi;\n\nimport org.bouncycastle.crypto.AsymmetricCipherKeyPair;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.digests.SHA256Digest;\nimport org.bouncycastle.crypto.Digest;\n\nimport java.io.IOException;\nimport java.util.List;\n\nimport it.unisa.dia.gas.crypto.jpbc.signature.bls01.generators.BLS01ParametersGenerator;\nimport it.unisa.dia.gas.crypto.jpbc.signature.bls01.params.BLS01Parameters;\nimport it.unisa.dia.gas.crypto.jpbc.signature.bls01.params.BLS01KeyParameters;\nimport it.unisa.dia.gas.crypto.jpbc.signature.bls01.params.BLS01PrivateKeyParameters;\nimport it.unisa.dia.gas.crypto.jpbc.signature.bls01.params.BLS01PublicKeyParameters;\nimport it.unisa.dia.gas.jpbc.Element;\nimport it.unisa.dia.gas.jpbc.Pairing;\nimport it.unisa.dia.gas.plaf.jpbc.pairing.PairingFactory;\n\n\npublic class PKRBLS {\n\n    private Context context;\n\n    /**\n     * Construct a PKR-BLS scheme instance.\n     * A PKR-BLS scheme instance.\n     * @param context Current application context\n     */\n    public PKRBLS(Context context) {\n        this.context = context;\n    }\n\n    /**\n     * Generate Type III pairing parameters for PKR-BLS scheme.\n     * Same as the original BLS scheme.\n     * @throws IOException Error when a.properties is not found.\n     */\n    @RequiresApi(api = Build.VERSION_CODES.O)\n    public BLS01Parameters setup() throws IOException {\n        BLS01ParametersGenerator setup = new BLS01ParametersGenerator();\n        setup.init(PairingFactory.getPairingParameters(MainActivity.getCacheFile(\"a.properties\", context).toPath().toString()));\n\n        return setup.generateParameters();\n    }\n\n    /**\n     * Generate public-secret key pair for PKR-BLS scheme.\n     * Same as the original BLS scheme.\n     * @param parameters Type III pairing parameters.\n     */\n    public AsymmetricCipherKeyPair keyGen(BLS01Parameters parameters) {\n        Pairing pairing = PairingFactory.getPairing(parameters.getParameters());\n        Element g = parameters.getG();\n\n        Element sk = pairing.getZr().newRandomElement();\n        Element pk = g.powZn(sk);\n\n        return new AsymmetricCipherKeyPair(\n                new BLS01PublicKeyParameters(parameters, pk.getImmutable()),\n                new BLS01PrivateKeyParameters(parameters, sk.getImmutable())\n        );\n    }\n\n    /**\n     * Sign signatures in PKR-BLS scheme.\n     * Same as the original BLS scheme.\n     * @param message         String message to be signed.\n     * @param privateKeyParam CipherParameters type of Secret key, converted and used for signing message.\n     * @param r               randomness used in pk.\n     */\n    public byte[] sign(String message, CipherParameters privateKeyParam, Element r) throws IOException {\n        // get pairing from private key\n        BLS01PrivateKeyParameters privateKey = (BLS01PrivateKeyParameters) ((BLS01KeyParameters) privateKeyParam);\n        Pairing pairing = PairingFactory.getPairing(privateKey.getParameters().getParameters());\n\n        // compute hash of the message\n        byte[] bytes = message.getBytes();\n        Digest digest = new SHA256Digest();\n        digest.reset();\n        digest.update(bytes, 0, bytes.length);\n        byte[] hash = new byte[digest.getDigestSize()];\n        digest.doFinal(hash, 0);\n        Element h = pairing.getG1().newElementFromHash(hash, 0, hash.length);\n\n        Element sig = h.powZn(privateKey.getSk().mul(r));\n\n        return sig.toBytes();\n    }\n\n    /**\n     * Verify signatures in PKR-BLS scheme.\n     * @param signature      Signature to be verified.\n     * @param message        The signed message.\n     * @param publicKeyParam CipherParameters type of Public key, converted and used for verifying message-signature pair.\n     */\n    public boolean verify(byte[] signature, String message, CipherParameters publicKeyParam) {\n        // get pairing from public key\n        BLS01PublicKeyParameters publicKey = (BLS01PublicKeyParameters) ((BLS01KeyParameters) publicKeyParam);\n        Pairing pairing = PairingFactory.getPairing(publicKey.getParameters().getParameters());\n\n        // compute hash of the message\n        byte[] bytes = message.getBytes();\n        Digest digest = new SHA256Digest();\n        digest.reset();\n        digest.update(bytes, 0, bytes.length);\n        byte[] hash = new byte[digest.getDigestSize()];\n        digest.doFinal(hash, 0);\n        Element h = pairing.getG1().newElementFromHash(hash, 0, hash.length);\n\n        Element sig = pairing.getG1().newElementFromBytes(signature);\n\n        Element temp1 = pairing.pairing(sig, publicKey.getParameters().getG());\n        Element temp2 = pairing.pairing(h, publicKey.getPk());\n\n        return temp1.isEqual(temp2);\n    }\n\n    /**\n     * Update public key with a random number r.\n     * @param publicKeyParam CipherParameters type of Public key, to be updated.\n     * @param parameters     public parameter of PKRBLS scheme.\n     * @param r              randomness for updating public key.\n     */\n    public CipherParameters updatePK(CipherParameters publicKeyParam, BLS01Parameters parameters, Element r) {\n        // Update the public key\n        Element pk = ((BLS01PublicKeyParameters) ((BLS01KeyParameters) publicKeyParam)).getPk();\n        Element updated = pk.powZn(r);\n        BLS01PublicKeyParameters updatedPK = new BLS01PublicKeyParameters(parameters, updated.getImmutable());\n\n        return updatedPK;\n    }\n\n    /**\n     * Update signature with a random number r.\n     * @param parameters public parameter of PKRBLS scheme.\n     * @param r          randomness for updating signature.\n     */\n    public byte[] updateSIG(byte[] signature, BLS01Parameters parameters, Element r) {\n        Pairing pairing = PairingFactory.getPairing(parameters.getParameters());\n\n        // Update the signature\n        Element sig = pairing.getG1().newElementFromBytes(signature);\n        Element updated = sig.powZn(r);\n        byte[] updatedSIG = updated.toBytes();\n\n        return updatedSIG;\n    }\n\n    /**\n     * Aggregate multiple signatures from PKR-BLS scheme.\n     * @param signatures A list of signatures to be aggregated by group multiplication.\n     * @param parameters public parameter of PKRBLS scheme.\n     */\n    public byte[] aggregate(List<byte[]> signatures, BLS01Parameters parameters) {\n        Pairing pairing = PairingFactory.getPairing(parameters.getParameters());\n\n        // get identity on G1 (For multiplication)\n        Element aggregate = pairing.getG1().newElement(1);\n\n        for (byte[] signature : signatures) {\n            Element temp = pairing.getG1().newElementFromBytes(signature);\n            aggregate = aggregate.mul(temp);\n        }\n        return aggregate.toBytes();\n    }\n\n    /**\n     * Verify aggregate signatures in PKR-BLS scheme.\n     * @param aggregate       Aggregate signature to be verified.\n     * @param messages        All messages embedded by the component signatures.\n     * @param publicKeysParam CipherParameters type of Public key, used for verifying\n  aggregate signature.\n     */\n    public boolean verifyAgg(byte[] aggregate, List<String> messages, List<CipherParameters> publicKeysParam) {\n        // get pairing from the first public key\n        BLS01PublicKeyParameters publicKey = (BLS01PublicKeyParameters) ((BLS01KeyParameters) publicKeysParam.get(0));\n        Pairing pairing = PairingFactory.getPairing(publicKey.getParameters().getParameters());\n\n        // compute pairing: e(agg, g)\n        Element agg = pairing.getG1().newElementFromBytes(aggregate);\n        Element temp1 = pairing.pairing(agg, publicKey.getParameters().getG());\n\n        // get identity on Gt (For following multiplication)\n        Element temp2 = pairing.getGT().newElement(1);\n\n        // handle each message, compute hash and multiplied pairing\n        for (int i=0; i<messages.size(); i++) {\n            // compute hash of the each message\n            byte[] bytes = messages.get(i).getBytes();\n            Digest digest = new SHA256Digest();\n            digest.reset();\n            digest.update(bytes, 0, bytes.length);\n            byte[] hash = new byte[digest.getDigestSize()];\n            digest.doFinal(hash, 0);\n            Element h = pairing.getG1().newElementFromHash(hash, 0, hash.length);\n            temp2 = temp2.mul(pairing.pairing(h, ((BLS01PublicKeyParameters) ((BLS01KeyParameters) publicKeysParam.get(i))).getPk()));\n        }\n\n        return temp1.isEqual(temp2);\n    }\n\n    /**\n     * Helper function\n     * Generate a value of Field Zr by a given integer.\n     * @param i             A given integer.\n     * @param parameters    public parameter of PKRBLS scheme.\n     */\n    public Element getEleZr(int i, BLS01Parameters parameters) {\n        Pairing pairing = PairingFactory.getPairing(parameters.getParameters());\n\n        Element e = pairing.getZr().newElement(i);\n        return e;\n    }\n\n    /**\n     * Helper function\n     * Sample a random value of Field Zr.\n     * @param parameters    public parameter of PKRBLS scheme.\n     */\n    public Element sampleEleZr(BLS01Parameters parameters) {\n        Pairing pairing = PairingFactory.getPairing(parameters.getParameters());\n\n        Element r = pairing.getZr().newRandomElement();\n        return r;\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/pbk_test/PKRBLS.java	(revision 564ceb39d9dc940a82a987182febd2ae3c234c40)
+++ app/src/main/java/com/example/pbk_test/PKRBLS.java	(date 1622801998849)
@@ -191,7 +191,7 @@
 
         // handle each message, compute hash and multiplied pairing
         for (int i=0; i<messages.size(); i++) {
-            // compute hash of the each message
+            // compute hash of each message
             byte[] bytes = messages.get(i).getBytes();
             Digest digest = new SHA256Digest();
             digest.reset();
@@ -211,7 +211,7 @@
      * @param i             A given integer.
      * @param parameters    public parameter of PKRBLS scheme.
      */
-    public Element getEleZr(int i, BLS01Parameters parameters) {
+    public Element setEleZr(int i, BLS01Parameters parameters) {
         Pairing pairing = PairingFactory.getPairing(parameters.getParameters());
 
         Element e = pairing.getZr().newElement(i);
Index: app/src/main/java/com/example/pbk_test/User.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.pbk_test;\n\nimport android.content.Context;\n\nimport androidx.room.Room;\n\nimport org.bouncycastle.crypto.AsymmetricCipherKeyPair;\nimport org.bouncycastle.crypto.CipherParameters;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport it.unisa.dia.gas.crypto.jpbc.signature.bls01.params.BLS01Parameters;\nimport it.unisa.dia.gas.jpbc.Element;\nimport it.unisa.dia.gas.jpbc.Field;\nimport it.unisa.dia.gas.jpbc.Pairing;\nimport it.unisa.dia.gas.plaf.jpbc.pairing.PairingFactory;\n\npublic class User {\n\n    public PKRBLS pkrbls;\n    private BLS01Parameters parameters;\n    public AsymmetricCipherKeyPair keyPair;\n    public CipherParameters nym;\n    private Element r;\n    public Database db;\n    public CompressedDatabase cdb;\n\n    /**\n     * Construct a new user.\n     * A normal user.\n     * Note: Normally, user should be CONSISTENT in a real application, since you don't want to\n     * lose your data after closing the application. However, in our demo, the user (and associated\n     * database) is newed every single time you enter the activity (UI).\n     * This is simply because we are here only to prove its performance, instead of developing a\n     * REAL application.\n     * @param context Current application context\n     * @throws IOException Error when a.properties is not found\n     */\n    public User(Context context) throws IOException {\n        this.pkrbls = new PKRBLS(context);\n        this.parameters = this.pkrbls.setup();\n        db = Room.databaseBuilder(context, Database.class, \"database-main\").build();\n        cdb = Room.databaseBuilder(context, CompressedDatabase.class, \"database-compressed\").build();\n    }\n\n    /**\n     * Generate initialKey pair.\n     * @throws IOException Error when a.properties is not found\n     */\n    public void keyGen() throws IOException {\n        this.keyPair = pkrbls.keyGen(this.parameters);\n        this.nym = this.keyPair.getPublic();\n        this.r = pkrbls.getEleZr(1, this.parameters);\n    }\n\n    /**\n     * Generate an Assertion and insert to database.\n     * @param attr      Attributes\n     * @param insert    Whether to insert this assertion into db\n     * @return          Assertion\n     */\n    public Assertion generateAssertion(String attr, boolean insert) throws IOException {\n        String msg = User.generateMsg(attr);\n        Assertion assertion = new Assertion(this.nym, msg, this.pkrbls.sign(msg, this.keyPair.getPrivate(), this.r));\n        if (insert)\n            db.assertionDao().insert(assertion);\n        return assertion;\n    }\n\n    /**\n     * Verify an assertion using public key contained.\n     * @param assertion Assertion containing signature to be verified\n     * @return          Verification result\n     */\n    public boolean verifyAssertion(Assertion assertion, Context context) throws IOException {\n        return this.pkrbls.verify(assertion.signature, assertion.msg, MainActivity.getCipherFromBytes(assertion.nym, assertion.g, context));\n    }\n\n    /**\n     * Compress all signatures\n     * @return Compressed signatures\n     */\n    public void save() throws IOException {\n        List<Assertion> assertions = this.db.assertionDao().getAll();\n        List<byte[]> signatures = new ArrayList<>();\n        List<Integer> ids = new ArrayList<>();\n        for (Assertion assertion: assertions) {\n            signatures.add(assertion.signature);\n            ids.add(assertion.id);\n        }\n        byte[] compressedSig = this.pkrbls.aggregate(signatures, pkrbls.setup());\n        cdb.compressedAssertionDao().insert(new CompressedAssertion(compressedSig, ids));\n        this.db.assertionDao().delete();\n    }\n\n    /**\n     * WIP\n     * @param signature\n     * @param db\n     * @return\n     */\n    public Assertion show(byte[] signature, Database db) throws IOException {\n        // WIP\n\n        // this.updateAssertions();\n        // delete all assertions in DB\n        return generateAssertion(\"\", false);\n    }\n\n    /**\n     * Update pseudonym.\n     * WIP\n     */\n    public void updateNym() {\n        this.r = this.pkrbls.sampleEleZr(this.parameters);\n        this.nym = this.pkrbls.updatePK(this.nym, this.parameters, r);\n    }\n\n    /**\n     * Update assertions.\n     * WIP\n     */\n    public void updateAssertions() {\n        // WIP\n        // Update assertions in DB\n    }\n\n    /**\n     * Generate message by adding randomness to attributes\n     * @param attr  Attributes\n     * @return      Message\n     */\n    public static String generateMsg(String attr) {\n        return attr + \"|\" + ThreadLocalRandom.current().nextInt(0, Integer.MAX_VALUE);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/pbk_test/User.java	(revision 564ceb39d9dc940a82a987182febd2ae3c234c40)
+++ app/src/main/java/com/example/pbk_test/User.java	(date 1622802013792)
@@ -53,7 +53,7 @@
     public void keyGen() throws IOException {
         this.keyPair = pkrbls.keyGen(this.parameters);
         this.nym = this.keyPair.getPublic();
-        this.r = pkrbls.getEleZr(1, this.parameters);
+        this.r = pkrbls.setEleZr(1, this.parameters);
     }
 
     /**
